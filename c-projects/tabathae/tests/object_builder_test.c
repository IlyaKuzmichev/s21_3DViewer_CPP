/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "object_builder_test.check" instead.
 */

#include "../object_builder.h"

#include <check.h>
#include <stdio.h>
#include <stdlib.h>

#include "../object.h"
#include "test_utils.h"

START_TEST(creation_test) {
  object_builder_t *builder = create_object_builder();

  ck_assert_ptr_nonnull(builder);
  ck_assert_uint_eq(0, builder->vertices_capacity);
  ck_assert_uint_eq(0, builder->faces_capacity);
  ck_assert_ptr_null(builder->object);

  destroy_object_builder(builder);
}
END_TEST

START_TEST(single_vertice) {
  object_builder_t *builder = create_object_builder();

  int error = add_vertice_to_object(builder, 1., 2., 3.);
  ck_assert_int_eq(OK, error);

  object_t *object = NULL;
  error = get_object(builder, &object);
  ck_assert_int_eq(OK, error);
  vertice_t vertices[] = {(vertice_t){1., 2., 3.}};
  object_t expected = (object_t){.vertices = vertices,
                                 .vertices_amount = 1,
                                 .faces = NULL,
                                 .faces_amount = 0};
  ck_assert_int_eq(1, compare_objects(&expected, object));

  destroy_object(object);
  destroy_object_builder(builder);
}
END_TEST

START_TEST(several_vertices) {
#define n 10

  object_builder_t *builder = create_object_builder();

  vertice_t expected_vertices[n] = {0};

  for (size_t i = 0; i < n; ++i) {
    double x = i;
    double y = 2 * i;
    double z = 3 * i;
    int error = add_vertice_to_object(builder, x, y, z);
    ck_assert_int_eq(OK, error);

    expected_vertices[i] = (vertice_t){x, y, z};
  }

  object_t expected = (object_t){.vertices = expected_vertices,
                                 .vertices_amount = n,
                                 .faces = NULL,
                                 .faces_amount = 0};

  object_t *object = NULL;
  int error = get_object(builder, &object);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(&expected, object));

  destroy_object(object);
  destroy_object_builder(builder);

#undef n
}
END_TEST

START_TEST(single_face) {
  object_builder_t *builder = create_object_builder();

  int error = add_vertice_to_object(builder, 0., 0., 0.);
  ck_assert_int_eq(OK, error);

  error = add_vertice_to_object(builder, 0., 1., 0.);
  ck_assert_int_eq(OK, error);

  error = add_vertice_to_object(builder, 0., 0., 1.);
  ck_assert_int_eq(OK, error);

  error = add_vertice_to_object(builder, 1., 0., 0.);
  ck_assert_int_eq(OK, error);

  int vertices_indexes[] = {1, 2, 3, 4};

  error = add_face_to_object(
      builder, vertices_indexes,
      sizeof(vertices_indexes) / sizeof(vertices_indexes[0]));
  ck_assert_int_eq(OK, error);

  vertice_t expected_vertices[] = {
      (vertice_t){0., 0., 0.}, (vertice_t){0., 1., 0.}, (vertice_t){0., 0., 1.},
      (vertice_t){1., 0., 0.}};
  size_t vsize = sizeof(expected_vertices) / sizeof(expected_vertices[0]);

  vertice_t *expected_face_vertices[] = {
      &(expected_vertices[0]), &(expected_vertices[1]), &(expected_vertices[2]),
      &(expected_vertices[3])};

  face_t expected_faces[] = {
      (face_t){.vertices = expected_face_vertices, .vertices_amount = vsize}};
  size_t fsize = sizeof(expected_faces) / sizeof(expected_faces[0]);

  object_t expected = (object_t){.vertices = expected_vertices,
                                 .vertices_amount = vsize,
                                 .faces = expected_faces,
                                 .faces_amount = fsize};

  object_t *object = NULL;
  error = get_object(builder, &object);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(&expected, object));

  destroy_object(object);
  destroy_object_builder(builder);
}
END_TEST

START_TEST(negative_index) {
  object_builder_t *builder = create_object_builder();

  int error = add_vertice_to_object(builder, 0., 0., 0.);
  ck_assert_int_eq(OK, error);

  error = add_vertice_to_object(builder, 0., 1., 0.);
  ck_assert_int_eq(OK, error);

  error = add_vertice_to_object(builder, 0., 0., 1.);
  ck_assert_int_eq(OK, error);

  error = add_vertice_to_object(builder, 1., 0., 0.);
  ck_assert_int_eq(OK, error);

  int vertices_indexes[] = {-4, -3, -2, -1};

  error = add_face_to_object(
      builder, vertices_indexes,
      sizeof(vertices_indexes) / sizeof(vertices_indexes[0]));
  ck_assert_int_eq(OK, error);

  vertice_t expected_vertices[] = {
      (vertice_t){0., 0., 0.}, (vertice_t){0., 1., 0.}, (vertice_t){0., 0., 1.},
      (vertice_t){1., 0., 0.}};
  size_t vsize = sizeof(expected_vertices) / sizeof(expected_vertices[0]);

  vertice_t *expected_face_vertices[] = {
      &(expected_vertices[0]), &(expected_vertices[1]), &(expected_vertices[2]),
      &(expected_vertices[3])};

  face_t expected_faces[] = {
      (face_t){.vertices = expected_face_vertices, .vertices_amount = vsize}};
  size_t fsize = sizeof(expected_faces) / sizeof(expected_faces[0]);

  object_t expected = (object_t){.vertices = expected_vertices,
                                 .vertices_amount = vsize,
                                 .faces = expected_faces,
                                 .faces_amount = fsize};

  object_t *object = NULL;
  error = get_object(builder, &object);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(&expected, object));

  destroy_object(object);
  destroy_object_builder(builder);
}
END_TEST

int object_builder_test(void) {
  Suite *s1 = suite_create("creation_test");
  TCase *tc1_1 = tcase_create("creation_case");
  Suite *s2 = suite_create("building_object_test");
  TCase *tc2_1 = tcase_create("vertices_only");
  TCase *tc2_2 = tcase_create("vertices_and_faces");
  SRunner *sr = srunner_create(s1);
  int nf;

  suite_add_tcase(s1, tc1_1);
  tcase_add_test(tc1_1, creation_test);
  suite_add_tcase(s2, tc2_1);
  tcase_add_test(tc2_1, single_vertice);
  tcase_add_test(tc2_1, several_vertices);
  suite_add_tcase(s2, tc2_2);
  tcase_add_test(tc2_2, single_face);
  tcase_add_test(tc2_2, negative_index);
  srunner_set_fork_status(sr, CK_NOFORK);

  srunner_add_suite(sr, s2);

  srunner_run_all(sr, CK_VERBOSE);
  nf = srunner_ntests_failed(sr);
  srunner_free(sr);

  return nf == 0 ? 0 : 1;
}
