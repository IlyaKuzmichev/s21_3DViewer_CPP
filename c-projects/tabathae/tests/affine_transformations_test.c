/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "affine_transformations_test.check" instead.
 */

#include <check.h>
#include <float.h>
#include <math.h>

#include "../object.h"
#include "../object_builder.h"
#include "test_utils.h"

START_TEST(test_move_x) {
  double distance = 5.;
  vertice_t expected_vertices[8] = {
      {1 + distance, 1., 0.},   {-1 + distance, 1., 0.},
      {-1 + distance, -1., 0.}, {1 + distance, -1., 0.},
      {1 + distance, 1., 2.},   {-1 + distance, 1., 2.},
      {-1 + distance, -1., 2.}, {1 + distance, -1., 2.},
  };
  object_t *expected = construct_test_cube(expected_vertices);

  object_t *actual = construct_basic_test_cube();
  int error = move_x(actual, distance);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_move_y) {
  double distance = -3;
  vertice_t expected_vertices[8] = {
      {1, 1 + distance, 0.},   {-1, 1 + distance, 0.}, {-1, -1 + distance, 0.},
      {1, -1 + distance, 0.},  {1, 1 + distance, 2.},  {-1, 1 + distance, 2.},
      {-1, -1 + distance, 2.}, {1, -1 + distance, 2.},
  };
  object_t *expected = construct_test_cube(expected_vertices);

  object_t *actual = construct_basic_test_cube();
  int error = move_y(actual, distance);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_move_z) {
  double distance = 16.;
  vertice_t expected_vertices[8] = {

      {1., 1., distance},       {-1., 1., distance},
      {-1., -1., distance},     {1., -1., distance},
      {1., 1., 2 + distance},   {-1., 1., 2 + distance},
      {-1., -1., 2 + distance}, {1., -1., 2 + distance},
  };
  object_t *expected = construct_test_cube(expected_vertices);

  object_t *actual = construct_basic_test_cube();
  int error = move_z(actual, distance);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_rotate_x) {
  double angle = M_PI_2;

  vertice_t expected_vertices[8] = {
      {1., 0., -1.}, {-1., 0., -1.}, {-1., 0., 1.}, {1., 0., 1.},
      {1., 2., -1.}, {-1., 2., -1.}, {-1., 2., 1.}, {1., 2., 1.},

  };
  object_t *expected = construct_test_cube(expected_vertices);

  object_t *actual = construct_basic_test_cube();
  int error = rotate_x(actual, angle);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_rotate_y) {
  double angle = M_PI;

  vertice_t expected_vertices[8] = {
      {-1., 1., 0.},  {1., 1., 0.},  {1., -1., 0.},  {-1., -1., 0.},
      {-1., 1., -2.}, {1., 1., -2.}, {1., -1., -2.}, {-1., -1., -2.},
  };
  object_t *expected = construct_test_cube(expected_vertices);

  object_t *actual = construct_basic_test_cube();
  int error = rotate_y(actual, angle);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_rotate_z) {
  double angle = M_PI_4;

  vertice_t expected_vertices[8] = {
      {M_SQRT2, 0., 0.},  {0., M_SQRT2, 0.},  {-M_SQRT2, 0., 0.},
      {0., -M_SQRT2, 0.}, {M_SQRT2, 0., 2.},  {0., M_SQRT2, 2.},
      {-M_SQRT2, 0., 2.}, {0., -M_SQRT2, 2.},
  };
  object_t *expected = construct_test_cube(expected_vertices);

  object_t *actual = construct_basic_test_cube();
  int error = rotate_z(actual, angle);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_scale_x) {
  double scale_factor = 5;

  vertice_t expected_vertices[8] = {
      {scale_factor, 1., 0.},        {-1. * scale_factor, 1., 0.},
      {-1. * scale_factor, -1., 0.}, {scale_factor, -1., 0.},
      {scale_factor, 1., 2.},        {-1. * scale_factor, 1., 2.},
      {-1. * scale_factor, -1., 2.}, {scale_factor, -1., 2.},
  };
  object_t *expected = construct_test_cube(expected_vertices);

  object_t *actual = construct_basic_test_cube();
  int error = scale_x(actual, scale_factor);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_scale_y) {
  double scale_factor = 10000.;

  vertice_t expected_vertices[8] = {
      {1., scale_factor, 0.},        {-1., scale_factor, 0.},
      {-1., -1. * scale_factor, 0.}, {1., -1. * scale_factor, 0.},
      {1., scale_factor, 2.},        {-1., scale_factor, 2.},
      {-1., -1. * scale_factor, 2.}, {1., -1. * scale_factor, 2.},
  };
  object_t *expected = construct_test_cube(expected_vertices);

  object_t *actual = construct_basic_test_cube();
  int error = scale_y(actual, scale_factor);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_scale_z) {
  double scale_factor = 0.25;

  vertice_t expected_vertices[8] = {
      {1., 1., 0.},
      {-1., 1., 0.},
      {-1., -1., 0.},
      {1., -1., 0.},
      {1., 1., 2. * scale_factor},
      {-1., 1., 2. * scale_factor},
      {-1., -1., 2. * scale_factor},
      {1., -1., 2. * scale_factor},
  };
  object_t *expected = construct_test_cube(expected_vertices);

  object_t *actual = construct_basic_test_cube();
  int error = scale_z(actual, scale_factor);
  ck_assert_int_eq(OK, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_move_for_infinity) {
  double distance = INFINITY;

  object_t *expected = construct_basic_test_cube();

  object_t *actual = construct_basic_test_cube();
  int error = move_x(actual, distance);
  ck_assert_int_eq(INVALID_ARGUMENTS, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_move_overflow) {
  double distance = DBL_MAX;

  object_t *expected = construct_basic_test_cube();

  object_t *actual = construct_basic_test_cube();
  int error = move_y(actual, DBL_MAX / 2);
  ck_assert_int_eq(OK, error);
  error = move_y(expected, DBL_MAX / 2);
  ck_assert_int_eq(OK, error);

  error = move_y(actual, distance);
  ck_assert_int_eq(CALCULATION_ERROR, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_rotate_for_infinity) {
  double angle = INFINITY;

  object_t *expected = construct_basic_test_cube();

  object_t *actual = construct_basic_test_cube();
  int error = rotate_y(actual, angle);
  ck_assert_int_eq(INVALID_ARGUMENTS, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_scale_for_infinity) {
  double scale_factor = INFINITY;

  object_t *expected = construct_basic_test_cube();

  object_t *actual = construct_basic_test_cube();
  int error = scale_z(actual, scale_factor);
  ck_assert_int_eq(INVALID_ARGUMENTS, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_scale_overflow) {
  double scale_factor = DBL_MAX;

  object_t *expected = construct_basic_test_cube();

  object_t *actual = construct_basic_test_cube();
  int error = scale_y(actual, 2);
  ck_assert_int_eq(OK, error);
  error = scale_y(expected, 2);
  ck_assert_int_eq(OK, error);

  error = scale_y(actual, scale_factor);
  ck_assert_int_eq(CALCULATION_ERROR, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_scale_zero_factor) {
  double scale_factor = 0.;

  object_t *expected = construct_basic_test_cube();

  object_t *actual = construct_basic_test_cube();

  int error = scale_z(actual, scale_factor);
  ck_assert_int_eq(INVALID_ARGUMENTS, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

START_TEST(test_scale_negative) {
  double scale_factor = -25.;

  object_t *expected = construct_basic_test_cube();

  object_t *actual = construct_basic_test_cube();

  int error = scale_z(actual, scale_factor);
  ck_assert_int_eq(INVALID_ARGUMENTS, error);

  ck_assert_int_eq(1, compare_objects(expected, actual));

  destroy_object(expected);
  destroy_object(actual);
}
END_TEST

int affine_transformations_test(void) {
  Suite *s1 = suite_create("test_affine_transformations");
  TCase *tc1_1 = tcase_create("test_move");
  TCase *tc1_2 = tcase_create("test_rotate");
  TCase *tc1_3 = tcase_create("test_scale");
  Suite *s2 = suite_create("test_erroneous_transformations");
  TCase *tc2_1 = tcase_create("test_move_errors");
  TCase *tc2_2 = tcase_create("test_rotate_errors");
  TCase *tc2_3 = tcase_create("test_scale_errors");
  SRunner *sr = srunner_create(s1);
  srunner_add_suite(sr, s2);
  int nf;

  suite_add_tcase(s1, tc1_1);
  tcase_add_test(tc1_1, test_move_x);
  tcase_add_test(tc1_1, test_move_y);
  tcase_add_test(tc1_1, test_move_z);

  suite_add_tcase(s1, tc1_2);
  tcase_add_test(tc1_2, test_rotate_x);
  tcase_add_test(tc1_2, test_rotate_y);
  tcase_add_test(tc1_2, test_rotate_z);

  suite_add_tcase(s1, tc1_3);
  tcase_add_test(tc1_3, test_scale_x);
  tcase_add_test(tc1_3, test_scale_y);
  tcase_add_test(tc1_3, test_scale_z);

  suite_add_tcase(s2, tc2_1);
  tcase_add_test(tc2_1, test_move_for_infinity);
  tcase_add_test(tc2_1, test_move_overflow);
  suite_add_tcase(s2, tc2_2);
  tcase_add_test(tc2_1, test_rotate_for_infinity);
  suite_add_tcase(s2, tc2_3);
  tcase_add_test(tc2_1, test_scale_for_infinity);
  tcase_add_test(tc2_1, test_scale_overflow);
  tcase_add_test(tc2_1, test_scale_zero_factor);
  tcase_add_test(tc2_1, test_scale_negative);
  srunner_set_fork_status(sr, CK_NOFORK);

  srunner_run_all(sr, CK_VERBOSE);
  nf = srunner_ntests_failed(sr);
  srunner_free(sr);

  return nf == 0 ? 0 : 1;
}
